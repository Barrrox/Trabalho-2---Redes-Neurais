# -*- coding: utf-8 -*-
"""Main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1anyVn8cjzlXelGme8SQEf-Axg2DwKUkw

# Classificação de obras de arte por movimento artístico

Autores: Ellen Brzozoski, João Silva, Lóra, Matheus Barros

# Imports
"""

import numpy as np
from tensorflow.keras.models import Sequential # type: ignore
from tensorflow.keras.layers import Dense, Flatten, Conv2D, MaxPooling2D, Input # type: ignore
from tensorflow.keras.utils import to_categorical # type: ignore
from scikeras.wrappers import KerasClassifier
from sklearn.model_selection import RandomizedSearchCV
from time import time

"""# Funções auxiliares

## FormatImage

A função formatImage recebe uma imagem desformatada como parametro e recorta ela para ter um tamanho fixo definido.
"""

"""Carregar base de dados"""


def otimizar_parametros():
  
  inicio = time()

  # Carrega o conjunto de dados
  x_train = np.load("imagens_treino.npy")
  y_train = np.load("labels_treino.npy")

  print(f"Tempo = {time() - inicio:2f}s : Dados de treino carregados")

  # Normaliza os valores dos pixels para que fiquem entre 0 e 1
  x_train = x_train / 255.0

  print(f"Tempo = {time() - inicio:2f}s : Pixels normalizados entre 0 e 1")

  # Converte os rótulos (labels) para categorias (one-hot encoding)
  y_train = to_categorical(y_train, 9)

  print(f"Tempo = {time() - inicio:2f}s : Rótulos covertidos para categorias")

  #2. Definindo o Modelo e Treinando

  def construir_model(optimizer='adam', conv1_filters=32, conv2_filters=64, dense_units=128):

    model = Sequential()
    model.add(Input(shape=(255, 255, 3)))
    model.add(Conv2D(conv1_filters, (3, 3), activation='relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Conv2D(conv2_filters, (3, 3), activation='relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Flatten())
    model.add(Dense(dense_units, activation='relu'))
    model.add(Dense(9, activation='softmax'))

    model.compile(optimizer=optimizer, loss='categorical_crossentropy', metrics=['accuracy'])
    return model
  
  # Empacotar
  model = KerasClassifier(model=construir_model, verbose=0)

  print(f"Tempo = {time() - inicio:2f}s : Modelo empacotado com KerasClassifier")

  # Espaço de busca dos hiperparâmetros
  parametros = {
    'model__optimizer': ['adam', 'rmsprop', 'sgd'],
    'model__conv1_filters': [16, 32, 64],
    'model__conv2_filters': [32, 64, 128],
    'model__dense_units': [64, 128, 256],
    'batch_size': [16, 32],
    'epochs': [5]
  }


  # Randomized Search
  random_search = RandomizedSearchCV(estimator=model, param_distributions=parametros,
                                    n_iter=10, cv=3, verbose=2)
  

  print(f"Tempo = {time() - inicio:2f}s : Instancia do RandomizedSearch criada")

  # Executar o ajuste
  modelo_convergido = random_search.fit(x_train, y_train)

  print(f"Tempo = {time() - inicio:2f}s : Modelo tunado")

  print(f"Árvore de decisão dos parâmetros tunados: {modelo_convergido.best_params_}")
  print()
  print(f"O melhor score é {modelo_convergido.best_score_}")




def main():

  otimizar_parametros()



if __name__ == "__main__":
  main()