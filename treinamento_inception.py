# -*- coding: utf-8 -*-
"""Main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1anyVn8cjzlXelGme8SQEf-Axg2DwKUkw

# Classificação de obras de arte por movimento artístico

Autores: Ellen Brzozoski, João Silva, Lóra, Matheus Barros

# Imports
"""

import numpy as np
from random import randint
from tensorflow.keras.models import Sequential, Model
from tensorflow.keras.layers import Dense, Flatten, Conv2D, MaxPooling2D, Input, Concatenate
from tensorflow.keras.utils import to_categorical
from sklearn.model_selection import train_test_split
from time import time


def treinar_modelo(TAM_TESTES, QNT_EPOCAS):
  
  inicio = time()

  # Carrega o conjunto de dados completo
  imagens = np.load("imagens_treino.npy")
  labels = np.load("labels_treino.npy")

  print(f"Tempo = {time() - inicio:2f}s : Dados carregados")

  # --- CORREÇÃO APLICADA AQUI ---
  # Divide os dados em treino e teste de forma correta, sem sobreposição
  x_train, x_test, y_train, y_test = train_test_split(
      imagens, 
      labels, 
      test_size=TAM_TESTES, 
      random_state=42 # random_state garante que a divisão seja a mesma sempre
  )
  
  print(f"Tempo = {time() - inicio:2f}s : Dados de treino e teste separados corretamente")


  # Transformando para numpy array para normalizar depois
  x_test = np.array(x_test)
  y_test = np.array(y_test)

  print(f"Tempo = {time() - inicio:2f}s : Conversão concluida")

  # lista de matrizes de pixel rgb

  # Normaliza os valores dos pixels para que fiquem entre 0 e 1
  x_train = x_train / 255.0
  x_test = x_test / 255.0

  print(f"Tempo = {time() - inicio:2f}s : Pixels normalizados entre 0 e 1")

  # Converte os rótulos (labels) para categorias (one-hot encoding)
  y_train = to_categorical(y_train, 9)
  y_test = to_categorical(y_test, 9)

  print(f"Tempo = {time() - inicio:2f}s : Rótulos covertidos para categorias")

  # --- Passo 1: Definir a função para o Módulo Inception ---
  # Esta função cria os 4 ramos paralelos e os concatena.
  def inception_module(x, filters_1x1, filters_3x3_reduce, filters_3x3, filters_5x5_reduce, filters_5x5, filters_pool_proj):
    """
    Cria um módulo Inception.
    Argumentos:
    x -- tensor de entrada
    filters_... -- número de filtros para cada convolução dentro do módulo
    """
    # Ramo 1: Convolução 1x1
    conv_1x1 = Conv2D(filters_1x1, (1, 1), padding='same', activation='relu')(x)

    # Ramo 2: Convolução 1x1 -> 3x3
    conv_3x3_reduce = Conv2D(filters_3x3_reduce, (1, 1), padding='same', activation='relu')(x)
    conv_3x3 = Conv2D(filters_3x3, (3, 3), padding='same', activation='relu')(conv_3x3_reduce)

    # Ramo 3: Convolução 1x1 -> 5x5
    conv_5x5_reduce = Conv2D(filters_5x5_reduce, (1, 1), padding='same', activation='relu')(x)
    conv_5x5 = Conv2D(filters_5x5, (5, 5), padding='same', activation='relu')(conv_5x5_reduce)

    # Ramo 4: MaxPooling -> 1x1
    pool_proj = MaxPooling2D((3, 3), strides=(1, 1), padding='same')(x)
    pool_proj_conv = Conv2D(filters_pool_proj, (1, 1), padding='same', activation='relu')(pool_proj)

    # Concatenar todos os filtros dos ramos
    output = Concatenate(axis=-1)([conv_1x1, conv_3x3, conv_5x5, pool_proj_conv])

    return output

  # --- Passo 2: Construir o modelo completo usando a API Funcional ---

  # Camada de Entrada
  input_layer = Input(shape=(255, 255, 3))

  # Camadas iniciais (pode manter como no original ou ajustar)
  x = Conv2D(32, (3, 3), activation='relu', strides=(2, 2), padding='same')(input_layer)
  x = MaxPooling2D((2, 2), strides=(2, 2), padding='same')(x)

  # Adicionando nosso Módulo Inception
  # Os números de filtros são exemplos, você pode ajustá-los
  x = inception_module(x,
                      filters_1x1=64,
                      filters_3x3_reduce=96,
                      filters_3x3=128,
                      filters_5x5_reduce=16,
                      filters_5x5=32,
                      filters_pool_proj=32)

  # Adicionando um segundo Módulo Inception para mais profundidade
  x = inception_module(x,
                       filters_1x1=128,
                       filters_3x3_reduce=128,
                       filters_3x3=192,
                       filters_5x5_reduce=32,
                       filters_5x5=96,
                       filters_pool_proj=64)

  x = MaxPooling2D((2, 2), strides=(2, 2), padding='same')(x)

  # Camadas de Classificação (iguais ao seu modelo original)
  x = Flatten()(x)
  x = Dense(128, activation='relu')(x)
  output_layer = Dense(9, activation='softmax')(x)

  # Criar e compilar o modelo
  model = Model(inputs=input_layer, outputs=output_layer, name='inception_style_model')

  # Visualizar a arquitetura do modelo
  model.summary()


  # Compila o modelo
  model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

  print(f"Tempo = {time() - inicio:2f}s : Modelo compilado")

  # Treina o modelo
  model.fit(x_train, y_train, epochs=QNT_EPOCAS, validation_data=(x_test, y_test))
  # Validarion_data serve só para caluclar val_accuracy e val_loss

  print(f"Tempo = {time() - inicio:2f}s : Modelo treinado")


  #3. Salvando o Modelo e os Pesos
  # Salva o modelo completo (arquitetura + pesos)

  model.save('model.keras')

  print(f"Tempo = {time() - inicio:2f}s : Modelo salvo")


def main():
	
  # Tamanho do conjunto de dados de testes em relação ao de treino
  # Ex: se TAM_TESTES = 0.16 então o conjunto de testes terá 16% do tamanho
  # do conjunto de treino
  TAM_TESTES = 1/10

  QNT_EPOCAS = 30

  treinar_modelo(TAM_TESTES, QNT_EPOCAS)



if __name__ == "__main__":
  main()